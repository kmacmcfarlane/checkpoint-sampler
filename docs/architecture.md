# Architecture

## 1) System overview

Checkpoint Sampler is a local-first application that runs entirely on a single Linux workstation via Docker. It consists of two services plus host filesystem access:

```
┌─────────────┐       HTTP        ┌─────────────────┐       HTTP        ┌─────────────────┐
│   Browser   │ ◀──────────────▶  │   Frontend      │ ◀──────────────▶  │   Backend       │
│   (LAN)     │    WebSocket      │   (Vue/Vite)    │    WebSocket      │   (Go/Goa)      │
└─────────────┘                   └─────────────────┘                   └────────┬────────┘
                                                                                 │
                                                                        ┌────────┴────────┐
                                                                        │                 │
                                                                   ┌────▼─────┐    ┌──────▼──────┐
                                                                   │  SQLite  │    │  Filesystem │
                                                                   │  (data/) │    │  (dataset   │
                                                                   └──────────┘    │   root)     │
                                                                                   └─────────────┘
```

- **Frontend** serves the browser UI and communicates exclusively with the backend API over HTTP and WebSocket.
- **Backend** owns all business logic, configuration, data persistence, filesystem scanning, and image serving.
- **SQLite** persists user preferences (dimension mapping presets). Mounted as a Docker volume for persistence across container restarts.
- **Filesystem** (dataset root) is mounted read-only into the backend container. Contains checkpoint output directories with image files.

## 2) Backend architecture

### 2.1 Layered structure

The backend follows strict separation of concerns across four layers:

```
┌────────────────────────────────────┐
│         cmd/                       │  Entrypoints, wiring, config loading
├────────────────────────────────────┤
│  internal/api/                     │  Goa transport, middleware, Swagger, WS
│  internal/api/design/              │  Goa DSL (source of truth for API)
│  internal/api/gen/                 │  Generated code (DO NOT EDIT)
├────────────────────────────────────┤
│  internal/service/                 │  Business logic, scanning, dimension
│                                    │  extraction, WebSocket hub
├────────────────────────────────────┤
│  internal/store/                   │  SQLite persistence, filesystem access
├────────────────────────────────────┤
│  internal/model/                   │  Domain structs and helpers
└────────────────────────────────────┘
```

**Rules:**
- `model` contains domain types shared across layers. No business logic.
- `service` contains business logic. It depends on `model` and on interfaces for store/provider access. It never imports `store` or `api` packages directly.
- `store` implements persistence interfaces (SQLite for presets) and filesystem interfaces (directory scanning, image reading). It defines its own persistence entities separate from domain model types.
- `api` handles HTTP transport via Goa v3, middleware (CORS), WebSocket upgrade, and Swagger hosting. It calls into service layer methods.
- `api/gen` is generated by Goa codegen and must never be hand-edited.
- `cmd` loads TOML configuration, wires dependencies, and starts the server. No business logic here.

### 2.2 Dependency flow

```
cmd  ──▶  api  ──▶  service  ──▶  store (via interfaces)
                       │
                       ▼
                     model
```

- Interfaces are defined in the consumer package (service defines the store/provider interfaces it needs).
- Store packages implement those interfaces.
- This enables testing service logic with mocks/stubs.

### 2.3 Configuration

The backend reads a TOML config file at startup (path overridable via `CONFIG_PATH` env var). Configuration includes:

- Dataset root directory (security boundary for all filesystem access)
- Server port
- SQLite database path
- Training run definitions (name, directory matching pattern, dimension extraction regexes)

See PRD section 4 for the full config schema.

### 2.4 Filesystem scanning

The scanning subsystem lives in the service layer, using a store-layer filesystem interface:

1. Given a training run, find all directories under root matching the run's regex pattern.
2. Apply dimension extraction regexes to each matching directory name.
3. Scan each directory for `.png` image files.
4. Parse query-encoded filenames to extract dimension key-value pairs.
5. Ignore the `_NNNNN_` batch suffix; when duplicates exist, use the highest batch number.
6. All paths are validated to stay within the configured root (path traversal rejected).

### 2.5 Image serving

Images are served from the filesystem through a dedicated API endpoint. The relative path is validated against the configured root. Responses include `Cache-Control: max-age=31536000, immutable` since checkpoint outputs are write-once.

### 2.6 WebSocket

A WebSocket endpoint pushes filesystem change events to connected clients. The backend uses fsnotify to watch directories belonging to the active training run. Events include new image files and new directories matching the training run pattern.

### 2.7 Error handling

Backend errors carry:
- A stable error code (string) for programmatic consumption by the frontend.
- A user-facing message (sanitized).
- An internal message for server logs (sanitized, no secrets).

The Goa API layer maps service errors to appropriate HTTP status codes and the `ErrorWithCode` response type.

## 3) Frontend architecture

### 3.1 Technology stack

- **Vue 3** with Composition API
- **Vite** for build and dev server (HMR)
- **TypeScript** with strict settings
- **Vitest** for testing

### 3.2 Directory structure

```
frontend/
├── src/
│   ├── api/          # Backend API client + WebSocket client
│   ├── components/   # Reusable presentational components
│   ├── views/        # Route-level pages
│   ├── stores/       # State management (dimensions, images, presets)
│   ├── lib/          # Shared utilities (filename parsing, sorting)
│   └── types/        # Shared TypeScript types
├── public/
└── tests/
```

### 3.3 Key principles

- **API isolation**: All backend communication goes through `src/api/`. Components never construct fetch requests directly.
- **Error normalization**: Backend error responses are normalized into a stable UI error shape in the API client layer.
- **Client-side caching**: Browser HTTP cache is leveraged via backend cache headers. Adjacent slider positions are proactively preloaded for instant display.

### 3.4 Key components

| Component | Purpose |
|-----------|---------|
| `TrainingRunSelector` | Dropdown to pick the active training run |
| `DimensionPanel` | Assign dimensions to X, Y, slider, combo roles |
| `PresetSelector` | Save/load/switch dimension mapping presets |
| `XYGrid` | Renders the image grid based on current mapping |
| `ImageCell` | Single grid cell: image + individual slider |
| `MasterSlider` | Top-level slider that drives all individual sliders |
| `ComboFilter` | Multi-select dropdown for a combo-assigned dimension |
| `ImageLightbox` | Modal overlay with zoom and pan for full-size viewing |

### 3.5 Navigation structure

| Route | Purpose |
|-------|---------|
| `/` | Main view: training run selector, dimension panel, X/Y grid |

## 4) Docker runtime

### 4.1 Operational mode (`make up`)

- Runs built/production-like frontend and backend containers.
- Dataset root mounted read-only into backend container.
- SQLite data directory mounted read-write for persistence.
- Backend binds `0.0.0.0` for LAN access.
- Frontend reachable in browser; backend serves API and Swagger UI at `/docs`.

### 4.2 Dev mode (`make up-dev`)

- Frontend runs Vite dev server with HMR.
- Backend runs with `air` for hot reload on code changes.
- Source directories mounted into containers for live editing.
- Watch test targets available: `make test-frontend-watch`, `make test-backend-watch`.

## 5) Data flow summary

```
User ──▶ Browser ──▶ Frontend (Vue) ──▶ Backend API (Goa) ──▶ Filesystem (images)
                          ▲                     │                     │
                          │                     ▼                     │
                          │               SQLite (presets)            │
                          │                                          │
                          ◀──────── WebSocket (live updates) ◀───────┘
                                                              (fsnotify)
```

All data flows through the backend. The frontend is a pure UI layer.
