# Architecture

## 1) System overview

This is a local-first application that runs entirely on a single Linux workstation via Docker. It consists of two services:

```
[system diagram goes here]
```

- **Frontend** serves the browser UI and communicates exclusively with the backend API over HTTP.
- **Backend** owns all business logic, data persistence, and external provider integrations.

## 2) Backend architecture

### 2.1 Layered structure

The backend follows strict separation of concerns across four layers:

```
┌────────────────────────────────────┐
│         cmd/                       │  Entrypoints, wiring, flags
├────────────────────────────────────┤
│  internal/api/                     │  Goa transport, middleware, Swagger
│  internal/api/design/              │  Goa DSL (source of truth for API)
│  internal/api/gen/                 │  Generated code (DO NOT EDIT)
├────────────────────────────────────┤
│  internal/service/                 │  Business logic
├────────────────────────────────────┤
│  internal/store/                   │  Persistence, providers
├────────────────────────────────────┤
│  internal/model/                   │  Domain structs and helpers
└────────────────────────────────────┘
```

**Rules:**
- `model` contains domain types shared across layers. No business logic.
- `service` contains business logic. It depends on `model` and on interfaces for store/provider access. It never imports `store` or `api` packages directly.
- `store` implements persistence interfaces and provider interfaces for external integrations. It defines its own persistence entities separate from domain model types.
- `api` handles HTTP transport via Goa v3, middleware (auth, CORS), and Swagger hosting. It calls into service layer methods.
- `api/gen` is generated by Goa codegen and must never be hand-edited.
- `cmd` wires dependencies and starts the server. No business logic here.

### 2.2 Dependency flow

```
cmd  ──▶  api  ──▶  service  ──▶  store (via interfaces)
                       │
                       ▼
                     model
```

- Interfaces are defined in the consumer package (service defines the store/provider interfaces it needs).
- Store and provider packages implement those interfaces.
- This enables testing service logic with mocks/stubs.

### 2.3 Error handling

Backend errors carry:
- A stable error code (string) for programmatic consumption by the frontend.
- A user-facing message (sanitized).
- An internal message for server logs (sanitized, no secrets).

The Goa API layer maps service errors to appropriate HTTP status codes and the `ErrorWithCode` response type.

## 3) Frontend architecture

### 3.1 Technology stack

- **Vue 3** with Composition API
- **Vite** for build and dev server (HMR)
- **TypeScript** with strict settings
- **Vitest** for testing

### 3.2 Directory structure

```
frontend/
├── src/
│   ├── api/          # Backend API client (single abstraction point)
│   ├── components/   # Reusable presentational components
│   ├── views/        # Route-level pages
│   ├── stores/       # State management (thin cache + workflow)
│   ├── lib/          # Shared utilities (markdown, formatting)
│   └── types/        # Shared TypeScript types
├── public/
└── tests/
```

### 3.3 Key principles

- **API isolation**: All backend communication goes through `src/api/`. Components never construct fetch requests directly.
- **No provider access**: The frontend never contacts external services. All channel operations go through the backend API.
- **Error normalization**: Backend error responses are normalized into a stable UI error shape in the API client layer.

### 3.4 Navigation structure

| Route | Purpose |
|-------|---------|
| TBD   | ...     |

## 4) Docker runtime

### 4.1 Operational mode (`make up`)

- Runs built/production-like frontend and backend containers.
- DB persisted via volume mount.
- Frontend reachable in browser; backend serves API and Swagger UI at `/docs`.

### 4.2 Dev mode (`make up-dev`)

- Frontend runs Vite dev server with HMR.
- Backend runs with `air` for hot reload on code changes.
- Source directories mounted into containers for live editing.
- Watch test targets available: `make test-frontend-watch`, `make test-backend-watch`.

## 5) Data flow summary

```
User ──▶ Browser ──▶ Frontend (Vue) ──▶ Backend API (Goa)
```

All data flows through the backend. The frontend is a pure UI layer.
