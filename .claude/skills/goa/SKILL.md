---
name: goa
description: Design-first API development with the Goa v3 framework for Go. Use when user asks to create a Goa service, design a Goa API, write Goa DSL, generate Goa code, add Goa endpoints, set up a Goa project, or work with goa.design. Covers DSL design, code generation, HTTP/gRPC transports, error handling, security, and interceptors.
disable-model-invocation: false
allowed-tools: Read, Write, Edit, Glob, Grep, Bash
---

# Goa v3 API Framework

Goa is a design-first framework for building microservices in Go. The module path is `goa.design/goa/v3`. You define APIs using Goa's Go-based DSL, then generate server/client code, OpenAPI specs, and protobuf definitions.

Before writing any Goa code, consult `references/dsl-reference.md` for the complete DSL function catalog and `references/patterns.md` for design patterns, error handling, security, and transport examples.

## Critical: Design-First Workflow

Goa follows a strict three-phase workflow. Never skip ahead.

### Phase 1: Design

Write API specifications in Goa's DSL. Design files live in `design/design.go` (or multiple files in `design/`). The DSL is imported via dot-import:

```go
package design

import . "goa.design/goa/v3/dsl"
```

Every design must define an `API` and at least one `Service` with `Method` definitions. Each method needs a `Payload` (request), `Result` (response), and transport mapping (`HTTP` and/or `GRPC`).

### Phase 2: Generate

```bash
goa gen <module>/design    # Regenerates gen/ directory (NEVER edit gen/ manually)
goa example <module>/design  # One-time scaffolding (won't overwrite your code)
```

`goa gen` recreates `gen/` entirely on every run. `goa example` generates starter `cmd/` and service implementation files only if they don't exist.

### Phase 3: Implement

Implement the generated service interface in your service file (e.g., `myservice.go` at project root). The interface is defined in `gen/<service>/service.go`.

```go
type myservicesrvc struct{ logger *log.Logger }

func NewMyService(logger *log.Logger) gen.Service {
    return &myservicesrvc{logger}
}
```

## Project Structure

```
myservice/
├── design/          # Your DSL files (you own these)
│   └── design.go
├── gen/             # Generated code (READ-ONLY, regenerated by goa gen)
│   ├── <service>/   # Service interfaces, endpoints, client
│   ├── http/        # HTTP server/client, openapi3.json
│   └── grpc/        # gRPC server/client, protobuf
├── cmd/             # Entry points (generated once by goa example, you own these)
│   ├── <service>/
│   └── <service>-cli/
├── <service>.go     # Your service implementation (you own this)
├── go.mod
└── go.sum
```

**Key rule:** Files in `gen/` are NEVER manually edited. Your code lives in `design/`, `cmd/`, and service implementation files.

## Quick Start: New Project

```bash
mkdir myservice && cd myservice
go mod init mymodule
# Create design/design.go with your API/Service/Method definitions
goa gen mymodule/design
goa example mymodule/design
go mod tidy
go run ./cmd/myservice
```

## Instructions

### Step 1: Understand the user's API requirements

Identify services, methods, payload/result types, transports (HTTP, gRPC, or both), and security needs.

### Step 2: Write the DSL design

Consult `references/dsl-reference.md` for the complete function catalog. Key elements:

- `API()` — Top-level API definition with title, description, servers
- `Service()` — Group of related methods
- `Method()` — Individual endpoint with Payload, Result, and transport mapping
- `Type()` / `ResultType()` — Data structures with validation
- Use `Field()` with numeric tags instead of `Attribute()` when gRPC is needed
- `Required()` — Mark required fields
- Validation: `Minimum`, `Maximum`, `Pattern`, `Enum`, `MinLength`, `MaxLength`, `Format`

### Step 3: Define transport mappings

In each `Method`, add `HTTP(func() { ... })` and/or `GRPC(func() { ... })`:

```go
HTTP(func() {
    GET("/resources/{id}")      // Path params map to payload fields
    Param("page")               // Query parameters
    Header("X-Request-ID:id")   // Header mapping
    Response(StatusOK)
})
```

### Step 4: Generate and implement

Run `goa gen` after every design change. Implement the service interface. Never edit files in `gen/`.

After codegen, run the project's test suite to verify that generated code compiles and existing tests still pass. Design changes often require updating service implementations to match the new generated interface.

### Step 4b: Wire up with NewHTTPHandler

All Goa HTTP transport setup (mux, servers, mounting, middleware) MUST live in a `NewHTTPHandler()` function in `internal/api/http.go` — NOT inline in `main.go`. See `references/patterns.md` "HTTP Handler Wireup (Preferred)" for the full pattern.

Key rules:
- `main.go` owns dependency injection: config → stores → services → endpoints. It calls `NewHTTPHandler(endpoints..., logger, debug)` and gets back `http.Handler`.
- `internal/api/http.go` owns HTTP transport: mux, decoder/encoder, server creation, `errorHandler`, mounting with route logging, debug middleware, and HTTP-level middleware (RequestID, Log, CORS).
- Always provide an `errorHandler` that logs with the request ID for correlation.
- When adding a new Goa service, add its endpoints parameter to `NewHTTPHandler` and wire it up inside that function.

### Step 5: Add error handling

Define errors at API, service, or method level. Map to HTTP status codes and gRPC codes. See `references/patterns.md` for examples.

### Step 6: Add security if needed

Use `BasicAuthSecurity`, `JWTSecurity`, `APIKeySecurity`, or `OAuth2Security`. Apply with `Security()` at API, service, or method level. Use `NoSecurity()` to exempt specific methods.

## Troubleshooting

**Error: `goa gen` fails with import errors**
Cause: Design package import path doesn't match go.mod module
Solution: Use the full Go module path, e.g., `goa gen mymodule/design`, not a filesystem path

**Error: Generated code has compilation errors after design change**
Cause: Stale generated code
Solution: Delete `gen/` and re-run `goa gen`. The entire directory is regenerated.

**Error: Service method not found / interface not satisfied**
Cause: Service implementation doesn't match the generated interface after a design change
Solution: Check `gen/<service>/service.go` for the current interface and update your implementation

**Error: gRPC field numbers missing**
Cause: Using `Attribute()` instead of `Field()` for gRPC methods
Solution: Use `Field(tag, name, type, description)` with numeric tags for gRPC payloads
